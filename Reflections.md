# Reflektioner kapitel 2
|Namn och förklaring|Reflektion och regler från Clean Code kapitel 2 Namngivning|
|-------------------|-------------------------------------|
|**Rovarsprak** namn på huvudklassen|**Intention-Revealing** <br />Om man inte vet vad rövarspråk är kanske jag borde vara tydligare.|
|**charsToSkip** namn på privat medlem|**Avoid Mental Mapping** <br />Namnet är hyfsat tydligt. Kanske borde jag skrivit ut **charactersToSkip** istället för att slippa "översätta" chars till characters.|
|**stringFunctions** namn på en instans av klassen **StringFunctions**|**Add Meaningful Context** <br /> Namnet borde kanske ändras till **stringUtilities** för att bli tydligare med sitt syfte. stringFunctions kan misstolkas.|
|**validateTextInput** namn på metod|**Don´t Add Gratuitous Context** <br /> Det räcker med att skriva **validateText**|
|**validRegEx** namn på variabel|**Make Meaningful Distinctions** <br /> Borde skriva **validRegExPattern** för tydlighets skull.|
## Kort reflektion kring kapitel 2
För mig har det varit mycket utvecklande att utveckla namngivningen av variabler och metoder. Jag har programmerat sedan början på 90-talet och namngivningen av variabler var inget man diskuterade. Enskilda bokstäver med ökande siffror som variabelnamn, function a och function b etc... När man dessutom arbetade in en texteditor utan hjälpmedel var det minst sagt en utmaning att testa och felsöka koden.

Bara att använda "Intention-Revealing Names" underlättar kodläsning och felsökning, men jag hamnar lätt i fällan att "förutsätta" vissa saker istället för att vara tydlig i namngivningen.

Boken tar också upp distinktionen mellan namngivning av klasser och metoder och att få in det "tänket" kan på pappret verka enkelt, men jag märker på mig själv att när jag är inne i kodandet är det lätt att glömma bort detta. 

Normalt sett brukar jag först koda en "lång" funktion och sen bryta ner den i mindre metoder, men efter att ha läst dessa kapitel ska jag försöka tänka mer "objektorienterat" och bygga upp koden med bra namngivna metoder som jag sen kodar upp när strukturen är på plats.


# Reflektioner kapitel 3
|Namn och förklaring|Reflektion och regler från Clean Code kapitel 2 Funktioner|
|-------------------|-------------------------------------|
|**translateToRovarSprak** namn på funktion|**Small functions**, **Do one Thing** <br /> Funktionen är relativt liten och fokuserad. Den översätter texten till Rövarspråk och följer principen att göra en sak. Den har dock nestade if/for-loopar. Därför borde jag bryta ur dessa och skapa funktioner som löser detta.<br /><br />**One level of abstraction per function**<br /> Funktionen hanterar en nivå av abstraktion så den hanterar översättning av ord.<br /><br />**Function argument** <br /> Funktionen har bara ett argument.<br /><br />**Prefer Exceptions to Returning Error Codes** <br /> Här finns det definitivt utvecklingspotential. Funktionen returnerar felmeddelanden istället för exceptions. Jag borde lägga till try-catchblock som returnerar exceptions på samtliga funktioner.<br /><br />**DRY** <br /> Jag borde bryta ut vissa if-satser som jag använder flera gånger till egna metoder inom klassen. Detta för att unvika att upprepa kod.<br /><br />**Command Query Separation** <br />Funktionen följer detta då den inte förändrar tillståndet på något utan bara returnerar ett värde.|
|**translateFromRovarSprak** namn på funktion|**Small functions**, **Do one Thing** <br /> Funktionen är relativt liten och fokuserad. Den översätter texten från Rövarspråk och följer principen att göra en sak. Den har dock nestade if/for-loopar. Därför borde jag bryta ur dessa och skapa funktioner som löser detta.<br /><br />**One level of abstraction per function**<br /> Funktionen hanterar en nivå av abstraktion då den hanterar översättning av ord.<br /><br />**Function argument** <br /> Funktionen har bara ett argument.<br /><br />**Prefer Exceptions to Returning Error Codes** <br /> Här finns det definitivt utvecklingspotential. Funktionen returnerar felmeddelanden istället för exceptions. Jag borde lägga till try-catchblock som returnerar exceptions på samtliga funktioner.<br /><br />**DRY** <br /> Jag borde bryta ut vissa if-satser som jag använder flera gånger till egna metoder inom klassen. Detta för att undvika att upprepa kod.<br /><br />**Command Query Separation** <br />Funktionen följer detta då den inte förändrar tillståndet på något utan bara returnerar ett värde.|
|**isRovarSprak** namn på funktion|**Small functions**, **Do one Thing** <br /> Funktionen är relativt liten och fokuserad. Den kontrollerar om texten som ska översättas är Rövarspråk eller inte och följer principen att göra en sak. Den har dock nestade if/for-loopar. Därför borde jag bryta ur dessa och skapa funktioner som löser detta.<br /><br />**One level of abstraction per function**<br /> Funktionen hanterar en nivå av abstraktion då den endast utför en kontroll och returnerar true/false<br /><br />**Function argument** <br /> Funktionen har bara ett argument.<br /><br />**Prefer Exceptions to Returning Error Codes** <br /> Här finns det definitivt utvecklingspotential. Funktionen returnerar felmeddelanden istället för exceptions. Jag borde lägga till try-catchblock som returnerar exceptions på samtliga funktioner.<br /><br />**DRY** <br /> Jag borde bryta ut vissa if-satser som jag använder flera gånger till egna metoder inom klassen. Detta för att unvika att upprepa kod.<br /><br />**Command Query Separation** <br />Funktionen gör en sak, kontrollerar om texten är rövarspråk eller inte.|
|**validateTextInput** namn på funktion|**Small functions**, **Do one Thing** <br /> Funktionen är liten och fokuserad. Den validerar text och följer principen att göra en sak. <br /><br />**One level of abstraction per function**<br /> Funktionen hanterar en nivå av abstraktion då den endast utför en kontroll och returnerar true/false<br /><br />**Function argument** <br /> Funktionen har bara ett argument.<br /><br />**Prefer Exceptions to Returning Error Codes** <br /> Jag borde lägga till try-catchblock som returnerar exceptions på samtliga funktioner.<br /><br />**DRY** <br /> Kanske att jag borde lägga variablen validRegEx som en privat variabel i klassen istället om den skulle behöva användas igen.<br /><br />**Command Query Separation** <br />Funktionen gör en sak, kontrollerar om texten är validerad eller inte.|
|**stringFunctions.isStringEmpty** namn på funktion från importerad klass|**Small functions**, **Do one Thing** <br /> Funktionen är liten och fokuserad. Den kontrollerar om strängen är tom eller inte.. <br /><br />**One level of abstraction per function**<br /> Funktionen hanterar en nivå av abstraktion då den endast utför en kontroll och returnerar true/false<br /><br />**Function argument** <br /> Funktionen har bara ett argument.<br /><br />**Prefer Exceptions to Returning Error Codes** <br /> Jag borde lägga till try-catchblock som returnerar exceptions på samtliga funktioner.<br /><br />**DRY** <br /> Då metoden ligger i en importerad klass följer jag principen om att inte upprepa kod.<br /><br />**Command Query Separation** <br />Funktionen gör en sak, kontrollerar om strängen är tom eller inte.|
## Kort reflektion kring kapitel 3
Funktioner ska vara korta och endast en sak... Ja, det är lättare sagt än gjort för min del. Som jag beskrev tidigare brukar jag först koda en lång funktion som gör "alla" saker och sen bryta ut metoderna ur den. Bara i denna "enkla" modul blir det utmanande för mig att bryta ut en if-sats till en egen metod som bara returnerar true/false. Jag tror att en del i detta är att jag i huvudsak programmerat JavaScript som är extremt förlåtande både vad gäller typer och struktur. Det är inga problem att skriva "spagettikod" i Javascript och få det att funka ändå.

Tidigare har jag gärna skapat metoder som jag tror hanterar en sak, men inser när jag läser boken att de metoder jag skapat har dolda beroenden och både förändrar tillstånd och returnerar värden.

Jag måste också utveckla min felhantering med try/catch-block och att kasta undantag. Återigen är Javascript alldeles för förlåtande och under årskurs 1 har vi haft "paket" som löser detta åt oss utan eftertanke.

## Kort reflektion kring min egen kodkvalitet
Jag behöver träna på att använda en annan grundstruktur innan jag börjar koda. I stället för att börja med att skriva en lång funktion och sen bryta ner det till klasser och moduler måste jag träna på att höja abstraktionsnivån på min kod och tänka mer objektorienterat.

Att använda "meaningful names" är en grundförutsättning för att jag ska lyckas med detta. Jag behöver också jobba med att undvika "Mental Mapping" då jag kommer ifrån en typ av programmering där jag använt förkortningar som jag nu inser att jag inte vet vad dom betyder när jag kommer tillbaka till kod jag inte tittat på på länge. Perspektivet att andra programmerare ska förstå min kod, och viceversa, har varit en ögonöppnare för mig. T.ex. så som vi jobbade under workshop 1.

Att få metoderna att göra bara en sak är också en utmaning för mig. Jag har ibland svårt att se att en if-sats skulle kunna brytas ut till en metod som returnerar true/false och ofta har jag "nästat" in mig i en annan loop som komplicerar det hela ännu mer.

Jag tycker att jag har blivit bättre på att förstå och använda "Command Query Separation" och en aha-upplevelse är att använda is-prefixet när jag bara ska returnera true/false. Ibland kan det vara svårt för mig att förstå om jag både gör någonting och returnerar något, men nu har jag förstått att skillnaden är om tillståndet på ett objekt förändras eller inte.

Som jag tidigare beskrivit har jag inte använt Exceptions speciellt mycket utan istället returnerat egna felkoder/felmeddelanden. På sin höjd har jag lagt in ett try/catch-block kring en funktion, men sen har jag bara slängt ut ett eget felmeddelnade i konsolen. Här har jag stor utvecklingspotential och behöver läsa in mer dokumentation om Exceptions.

Jag har fått många aha-upplevelser under dessa första veckor av denna kurs och känner att jag sakta men säkert förbättrar både min kodkvalitet!
